# ğŸ§® Q7 â€“ Huffman Coding (ADSA Lab 04)

## ğŸ“˜ Problem Statement
Write a program to **encode data from a text file using Huffman Coding**.

The program must:
- Read characters from an **input text file**
- Count frequency of each character
- Build the **Huffman Tree**
- Generate Huffman **prefix-free binary codes**
- Encode the original text using these codes
- Save:
  - All Huffman codes â†’ `codes.txt`
  - Encoded bitstream â†’ `encoded_output.txt`

---

## ğŸ“‚ Code Files

| File Name | Description |
|----------|-------------|
| `Q7_Huffman.c` | Full implementation of Huffman Coding including frequency calculation, tree construction, code generation, and output file writing. |
| `test_Q7_Huffman.c` | Comprehensive **MUnit test suite** validating tree creation, code correctness, special cases, and output file generation. |
| `munit.c` / `munit.h` | MUnit testing framework used to automatically run the Huffman test suite. |

---

## ğŸ§  Code Overview

This program implements **Huffman Coding**, a lossless compression method that assigns **shorter codes to frequent characters** and longer codes to infrequent ones.

The implementation covers four major steps:

### ğŸ”¹ **1. Reading Input File & Counting Frequencies**

The program asks for a text filename:

```sql
Enter input text file name: input.txt
```

Each character frequency is counted:

```c
freq[(unsigned char)c]++;
```

### ğŸ”¹ **2. Huffman Tree Construction**

A **min-heap** is used to repeatedly extract the two nodes with minimum frequency:

```c
Node* left = extractMin(&heap);
Node* right = extractMin(&heap);
```

These nodes are combined:

```c
Node* combined = newNode('\0', left->freq + right->freq);
combined->left = left;
combined->right = right;
```

This continues until one node remains â†’ this is the **Huffman root node**.

### ğŸ”¹ **3. Generating Huffman Codes**

Codes are generated by traversing the Huffman tree:
- Left child â†’ append `'0'`
- Right child â†’ append `'1'`

```c
code[depth] = '0';
generateCodes(root->left, code, depth + 1, codes);

code[depth] = '1';
generateCodes(root->right, code, depth + 1, codes);
```

**âœ” Special Case: Single Character File**

If the entire file contains only one character (e.g., `"aaaaaa"`), its code must not be empty:

```c
if (depth == 0) { code[0] = '0'; code[1] = '\0'; }
```

### ğŸ”¹ **4. Writing Output Files**

**a) Huffman Codes** â†’ `codes.txt`

Example:

```rust
'a' -> 00
'b' -> 11
'c' -> 10
'd' -> 01
```

**b) Encoded Bitstream** â†’ `encoded_output.txt`

Example encoded output:

```rust
00111001
```

---

## ğŸ§‘â€ğŸ’» Usage

### â–¶ï¸ Compile & Run Main Program

```bash
gcc Q7_Huffman.c -o Q7_Huffman
./Q7_Huffman
```

Place an input file (e.g., `input.txt`) in the same directory.

---

### ğŸ“¥ Input Example

```bash
abcd
```

---

### ğŸ“¤ Output Example

```bash
Encoding complete!
Huffman codes saved in: codes.txt
Encoded bitstream saved in: encoded_output.txt
```

****codes.txt****

```rust
'a' -> 00
'b' -> 11
'c' -> 10
'd' -> 01
```

****encoded_output.txt****

```rust
00111001
```

---

## ğŸ§© MUnit Code Overview

The file **`test_Q7_Huffman.c`** contains automated MUnit test cases that validate the correctness of the Huffman Coding implementation.  
Each test independently builds a Huffman Tree, generates codes, encodes text, and verifies expected behavior.

### ğŸ” What Is Tested?

| Test Case            | Purpose                                                                 |
|----------------------|-------------------------------------------------------------------------|
| `/basic/acbd`        | Ensures Huffman codes for `"abcd"` are generated and encoding is valid. |
| `/repeat/aaaaaa`     | Validates the **single-character special case** (`"aaaaaa"` â†’ code `"0"`). |
| `/mixed/text`        | Tests Huffman encoding for `"hello world"` including the space character. |
| `/file/output`       | Confirms `codes.txt` and `encoded_output.txt` are created correctly.     |

### âœ” Example Assertions Used

```c
munit_assert_string_not_equal(codes['a'], "");
munit_assert_string_not_equal(encoded, "");

munit_assert_int(freq['a'], ==, 6);                  // For repeated char test
munit_assert_int(strlen(encoded), ==, 6 * strlen(codes['a']));

munit_assert_true(fopen("codes.txt", "r") != NULL);  // Check file creation
munit_assert_true(fopen("encoded_output.txt", "r") != NULL);
```

### âœ” What These Tests Ensure

- Huffman tree is built correctly
- Code generation works for **all characters present in input**
- Special cases (like single-character files) are handled correctly
- Encoded output length matches expected bit-length
- Output files are created successfully
- No character receives an empty or invalid code

These MUnit tests guarantee correctness, reliability, and stability of the Huffman encoding implementation across multiple input patterns.

---

### â–¶ï¸ Compile & Run MUnit Tests

```bash
gcc -DTEST_MODE test_Q7_Huffman.c Q7_Huffman.c munit.c -o test_Q7
./test_Q7
```

---

### ğŸ§ª MUnit Testing Output

```bash
Running test suite with seed 0x15534978...
/Q7_Huffman_Tests/basic/acbd         [ OK    ] 
/Q7_Huffman_Tests/repeat/aaaaaa      [ OK    ] 
/Q7_Huffman_Tests/mixed/text         [ OK    ] 
/Q7_Huffman_Tests/file/output        [ OK    ] 
4 of 4 (100%) tests successful, 0 (0%) test skipped.
```
